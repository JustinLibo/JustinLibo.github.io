{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://github.com/JustinLibo/JustinLibo.github.io.git","root":"/JustinLibo/JustinLibo.github.io.git/"},"pages":[{"title":"contact","date":"2021-02-28T15:21:17.000Z","updated":"2021-02-28T15:22:50.258Z","comments":true,"path":"contact/index.html","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2021-02-28T14:51:09.000Z","updated":"2021-02-28T14:51:47.975Z","comments":true,"path":"about/index.html","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-02-28T14:48:33.000Z","updated":"2021-02-28T14:49:18.757Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-02-28T14:51:18.000Z","updated":"2021-02-28T14:52:03.238Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-28T14:50:57.000Z","updated":"2021-02-28T14:52:24.172Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"article title","slug":"article-title","date":"2021-02-28T13:28:14.000Z","updated":"2021-02-28T15:48:33.710Z","comments":true,"path":"2021/022846815.html","link":"","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/2021/022846815.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-02-25T13:13:51.582Z","updated":"2021-02-28T15:48:33.708Z","comments":true,"path":"2021/022516107.html","link":"","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/2021/022516107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"如何用Hexo优雅的书写文章","slug":"写文章","date":"2021-01-03T00:09:10.000Z","updated":"2021-02-28T15:48:33.712Z","comments":true,"path":"2021/010362216.html","link":"","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/2021/010362216.html","excerpt":"","text":"MarkDown是什么这里就不多说了，具体参考我的技术博客，同时这里推荐一下我的个人网站，使用的是hexo的butterfly主题：https://lovelijunyi.gitee.io/ 了解文章目录所有的文章都是放在主目录下source文件下的_posts目录下的，这里参考我的存放目录E:\\mblog\\source\\_posts 这里作出两点说明： 1. 该目录下可以再创建目录，系统可以识别到多层文件夹中的文章，方便分类 2. 如果用命令生成的新文章一定是在_posts主目录下 熟悉操作指令其实就是一句话，再把生成的文章拖到_posts目录下你自己创建的文件夹即可，文件后缀为.md hexo n 你的文章名 Tips： 如果嫌麻烦，复制md文件再粘贴也是个好办法 开始书写文章写MarkDown这里推荐Typora，非常好用，点开创建的文件，先看看里面有啥 title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 两个虚线之间的内容就是叫Front-matter，主要是你文章的配置，具体配置如下，这里不同主题不一样，我以Matery主题为例 Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。配置选项 默认值 描述title Markdown 的文件标题 文章标题，强烈建议填写此选项date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一author 根 _config.yml 中的 author 文章作者img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtop true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags 无 文章标签，一篇文章可以多个标签keywords 文章标题 文章关键字，SEO 时需要reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 1.如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 2.date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 3.如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 4.您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最全示例 title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: Typora Markdown --- # 标题 title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; author: 无敌小小弋 # 简述 summary: # 使用自定义封面 img: # 是否置顶true，或者去掉 top: true # 轮播 cover: # 轮播图 coverImg: # 标签 tags: # 分类 categories: # 是否加密文章，SHA256加密 password: --- Tips：你会发现一个问题，每次hexo n的时候Front-matter中内容少的可怜，那怎么修改默认的格式呢？只要去主目录下找到scaffolds文件夹下找到一个post.md文件修改即可，这里是我的目录C:\\Users\\user\\Desktop\\lovelijunyi\\scaffolds，例如我的 标题title: 如何用Hexo优雅的书写文章date: 1609632550000author: 无敌小小弋 简述summary: 使用自定义封面img: 是否置顶true，或者去掉top: true 轮播cover: 轮播图coverImg: 标签tags: 分类categories: 是否加密文章，SHA256加密password: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 首行缩进方法 由于markdowm会自动限定格式，所以缩进显得比较困难，通常我们使用Tab按键或者打空格实现的缩进都只能缩进一小部分，这时可以通过占位符实现更多的缩进效果，使得文章变得美观 一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。有如下几种方法： 一个空格大小的表示：&amp;ensp;或&amp;#8194;，此时只要在相应需要缩进的段落前加上 4个 如上的标记即可，注意要带上分号。 两个空格的大小表示：&amp;emsp;或&amp;#8195;，同理，使用2个即可缩进2个汉字，推荐使用该方式。 不换行空格：&amp;nbsp;或&amp;#160;，使用4个&amp;#160;即可。 范例 不使用任何缩进效果 使用Tab实现缩进 在前面打上很多空格实现缩进 使用4个&amp;#160;实现缩进 使用2个&emsp;实现缩进 使用4个&ensp;实现缩进加粗指令不生效 **注意：**这是一个指令不生效的演示 *\\c\\d\\f* 以上两种情况都会导致加粗不生效，前者怀疑是符号和加粗语句冲突了，后者斜杠和加粗语句冲突了解决办法 不要把符号包括进去加粗，注意：这是一个加粗演示 后面空开一格（基本能解决大多数冲突），注意： 这是一个加粗演示 使用html语句来实现，用strong标签包裹","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"study","slug":"study","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/study/"}],"author":"JustinBo"},{"title":"hexo搭建博客步骤","slug":"博客搭建","date":"2021-01-02T03:19:08.000Z","updated":"2021-02-28T15:48:33.715Z","comments":true,"path":"2021/010263100.html","link":"","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/2021/010263100.html","excerpt":"","text":"hexo简介hexo 自称为：快速、简洁且高效的博客框架。 笔者用起来确实还可以，大概介绍下几个特性： 提供了不同的layout，可将文章存为草稿，需要时publish即可； 可维护全局的数据，在source/_data文件夹下添加yaml文件，通过site.data获取； 可指定文件的特有变量，通过Front-matter实现； 支持模板，在scaffolds文件夹下可自定义模板，并进行发布； 支持标签插件，可以在文章文件中使用标签%%来插入特定内容； 提供命令行操作，如：hexo init初始化项目、hexo new新建文章、hexo pulish发布草稿文件、hexo generate生成静态文件、hexo server启动服务器； hexo搭建博客步骤 前提是必须安装好git和nodejs； 执行 “npm install -g hexo-cli”，安装好hexo； 选定文件夹，通过 “hexo init $folder” 初始化一个名为 $folder 的文件夹； cd $folder, 再执行npm install，至此hexo的博客框架已经搭建完成！ 完成上述步骤后，可执行hexo server, 访问http://localhost:4000, 会发现一个HelloWorld页面已经可以访问！","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"study","slug":"study","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/study/"}],"author":"JustinBo"},{"title":"Docker基础","slug":"Docker基础","date":"2020-11-02T03:19:08.000Z","updated":"2021-02-28T15:48:33.716Z","comments":true,"path":"2020/110216621.html","link":"","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/2020/110216621.html","excerpt":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。","text":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker概述 为什么会出现Docker 在我们日常开发中，可能会出现这样的问题。在我们本机跑是可以正常执行的，但是发布到测试环境的时候，同一份代码就会出现错误。这就是运行的环境的不同导致的。 一款产品从开发到上线，从操作系统、到运行环境、再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，在多个版本迭代之后，不同版本对环境的兼容性，都是需要考虑的问题 Docker的出现就是为了解决上述类似的问题。开发人员给运维人员的不再是单独的jar包，而是包含代码、配置、系统以及数据的整体可运行的软件，也就是带运行环境的软件（Docker镜像）。 Docker理念 Docker是基于Go语言实现的云开源项目 Docker的主要目标是“Build,Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以说是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行” Docker是在Linux容器的基础上实现的，将应用运行在Docker容器上面，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到其他的机器上面一键部署，简化操作 Docker是解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 Docker能做什么 虚拟机技术 虚拟机技术就是一种带环境安装的一种解决方案，比如在本机上通过虚拟机安装Linux来充当服务器，运行之后就跟真正的服务器没有区别。 虚拟机的缺点：资源占用多、启动慢、需要模拟硬件来创建“真正可用”的系统 容器虚拟化技术 在介绍容器虚拟化技术之前，需要了解另一种虚拟化技术：Linux容器（Linux Containers，缩写LXC） Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需要的库资源和设置。系统因此变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 Docker和传统虚拟化的不同 传统虚拟技术是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行需要的应用进程 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核（如上图中的Kernel），而且也没有进行硬件模拟。因此更加轻便 虚拟化技术的每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。 hypervisor: 虚拟机监控程序 开发/运维（DevOps） 更快速的应用交付和部署 更便捷的升级和扩缩容 更简单的系统运维 更高效的计算资源利用 企业级使用针对短时高峰访问进行动态扩缩容等等 Docker安装 Docker安装 Docker架构图 Docker的基本组成 镜像（image） Docker镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。 容器（container） Docker利用容器独立运行一个或一组应用。容器是用镜像创建的运行实例。 容器可以被启动、开始、停止、删除。每个容器之间都是相互隔离的、保证安全的平台。 可以将容器看作是一个简易的Linux环境（包含root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 类比 仓库（repository） 仓库是集中存放镜像文件的场所。 仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内公开的仓库包括阿里云、网易云等等。 小总结 Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看做是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。 image文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过Docker客户端创建一个对应的运行实例，也就是我们的容器。 至于仓储，就是一个放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中下载就可以了。 安装步骤（CentOS）：链接 HelloWorld 启动Docker命令：systemctl start docker 运行Hello World：docker run hello-world 运行过程分析 Docker run 底层原理 Docker是怎么工作的 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机的容器上。容器，是一个运行环境，也就是Docker图标中的集装箱。 为什么Docker比VM快 Docker比虚拟机有更少的抽象层。Docker不需要像虚拟机一样虚拟化硬件资源，运行在Docker容器上的程序都是直接使用的实际物理机的硬件资源。因此在CPU、内存利用率上Docker将会有更加明显的优势。 Docker利用的是宿主机的内核。因此，当新建一个容器时，不需要像虚拟机一样重新加载一个操作系统内核。因此减少了加载内核系统这一浪费时间的过程，Docker省略了这个过程，所以创建Docker容器时秒级的。 Docker Engine直接代替了虚拟机监控进程（Hypervisor）以及Guest OS，直接使用宿主机的内核。 Docker命令 帮助命令 docker version docker info docker --help 镜像命令 docker images：列出本地主机上的镜像信息 REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 VIRTUAL SIZE：镜像大小 同一个仓库源中可以有多个TAG，用来区分仓库源中的不同版本，可以使用REPOSITORY:TAG来区分不同版本的镜像 如果不指定镜像的版本标签，Docker默认使用的是latest版本 docker images -a：列出本地所有的镜像（含中间映像层） docker images -qa：显示所有的镜像ID docker images --digests：显示镜像的摘要信息 docker images --no-trunc：显示镜像的完整信息 docker search xxx：从Docker Hub查找镜像 docker search -s 30 tomcat：查找STARS在30以上的tomcat镜像 docker pull xxx：下载镜像 docker pull xxx:TAG：下载指定版本的镜像 不写TAG的话 默认使用的是latest docker rmi xxx：删除某个镜像 无法删除正在运行中的镜像文件 docker rmi -f hello-world：强制删除 图中显示 不带TAG删除的话 默认是latest docker rmi -f 镜像1 镜像2：删除多个镜像 docker rmi -f $(docker images -qa)：删除全部镜像 容器命令 有镜像才能创建容器，以下都是运行在Docker上的CentOS为例进行的（docker pull centos） docker run：新建并启动容器 运行Docker上的CentOS -i，-t可以写成-it，表示以交互模式运行 下图中命令行的用户已经不是阿里云的CentOS了，已经是Docker中的CentOS了 OPTIONS说明 – name=”容器名”，为容器指定一个名字 -d：后台运行容器，并返回容器ID，也即启动守护式容器 -i：以交互模式运行容器 -t：为容器重新分配一个伪输入终端 -P：随机端口映射 -p：指定端口映射，有以下4中格式 ​ ip:hostPort:containerPort ​ ip::containerPort ​ hostPort:containerPort ​ containerPort docker ps列出当前所有正在运行的容器 -a：列出当前所有正在运行的容器+历史上运行过的容器 -l：显示最近创建的容器 -n：显示最近n个创建的容器 -q：静默模式，只显示容器编号 –np-trunc：不截断输出（就是显示完整的容器信息） 退出容器 exit：容器退出且停止 Ctrl+P+Q：容器退出不停止 docker start：启动容器 docker restart：重启容器 docker stop：停止容器 docker kill：强制停止容器 docker rm：删除已经停止的容器 容器命令（重要） 启动守护式容器 docker run -d xxx 后台启动的容器却没有在运行？ 因为：Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是一直挂起的命令（比如运行top，tail），就是会自动退出的 这是Docker的机制问题造成的，后台运行的容器启动后，会立即kill掉，因为Docker觉得后台运行的程序无事可做。 所以，最佳的解决方案是将运行的程序以前台进程的形式运行 查看容器日志 docker logs -f -t --tail 容器id -t：加入时间戳 -f：跟随最新的日志打印 –tail 数字：显示最后多少条 查看容器内运行的进程 docker top 容器id 查看容器内部细节（详细信息） docker inspect 容器ID 进入正在运行的容器并以命令行交互 docker attach 容器ID docker exec -it 容器ID 命令操作 两个命令的区别 attach：进入到Docker，之后再在Docker里面进行操作 exec：在宿主机对Docker进行操作 从容器内拷贝文件到主机上 docker cp 容器ID：容器内路径 目的主机路径 Docker镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包含代码以及运行环境。 UnionFS（Union File System）：联合文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFS是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。特性就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统包含所有的文件和目录。 Docker镜像加载原理 bootfs（boot filesystem）：主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统会卸载bootfs。 rootfs（root filesystem）：在bootfs之上。包含典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同操作系统发行版，比如Ubuntu，CentOS等 解释为什么Docker中的CentOS那么小（200M左右） 由于Docker中的CentOS运行在Docker之上，Docker是一个精简的Linux系统，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以，因为底层直接使用的是宿主机的Kernel，自己只需要提供rootfs就可以了。由此可见对于不同发行版的系统，bootfs基本是一致的，只需要提供对应的rootfs即可。 分层镜像 比如下图中我们从仓库中下载nginx镜像，发现下载的不仅仅是最终的镜像 过程中还下载了其他的文件 也就是说这个镜像是多层构成的 这就解释了在Docker中tomcat为什么需要400+M 因为tomcat需要运行的环境： Kernel–&gt;CentOS–&gt;jdk–&gt;tomcat，虽然我们最后看到的是tomcat，但是他需要这么多文件的支持，这就导致Docker上的tomcat比较大。 Docker为什么采用分层结构 共享资源，比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。而且镜像的每一层都可以被共享。（UnionFS分层继承） 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”，“容器层”之下的都叫做“镜像层”。 Docker镜像commit 之前运行的容器，我们docker run使用的都是默认的镜像配置，当我们需要使用我们自定义的配置的时候，就需要修改镜像文件，然后commit之后生成新的镜像，运行新的镜像就是我们自定义配置的镜像了。 演示案例 tomcat为例，删除tomcat的文档系统，commit生成新的tomcat镜像文件 运行Docker中的comcat -p 主机端口：docker容器端口 首先，需要在阿里云的安全组中配置8888端口，否则的话 是不能进行访问的此端口的 我们访问的时候的地址 出现404错误，我们进入到Docker中tomcat的目录，发现 wenapps目录是空的 docker exec -it 容器ID /bin/bash 而webapps下面还有一个webapps.dist 原来tomcat的文件都存放在这个目录下 重命名 webapps.dist为webapps 本地进行访问 -p以及-P的区别 -p：指定端口 -P：随机端口 在运行一个tomcat 查看正在运行的容器 删除docs目录 commit生成我们自定义的镜像 未删除之前 可以访问到 并且在webapps目录下有docs文件夹 删除docs目录 commit容器副本 生成我们自定义的镜像文件 提交容器副本使之成为一个新的镜像 查看镜像 运行我们自定义的镜像生成的容器 再次访问镜像的时候发现已经找不到文档了 后台运行 -d 后台运行 -it 交互式运行 容器数据卷是什么 在Docker的使用过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，所以这就涉及到Docker容器的数据操作。 容器中数据管理主要有两种方式：数据卷和数据卷容器。 数据卷就是数据(一个文件或者文件夹)。数据卷是特殊的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的是数据的永久化，是完全独立于容器的生命周期，不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理。 能干嘛 容器数据持久化 容器之间继承+共享数据 数据卷容器内添加 直接命令添加 创建数据卷 docker run -it -v 宿主机路径:容器内路径 镜像名 -v：volume n. 量；体积；卷；音量；大量；册 上述命令表示（或者理解为）：在宿主机的宿主机目录创建一个文件夹和镜像生成的容器目录下创建一个文件夹，这连个文件夹可以完成宿主机和容器的数据共享。 演示 未创建数据卷之前 Docker中的CentOS根目录的文件夹 未创建数据卷之前 阿里云宿主机的CentOS根目录 创建数据卷 查看宿主机根目录 已经创建文件夹HostVolume 在Docker中运行的CentOS容器的根目录下也已经创建出DockerVolume 查看容器是否挂载成功 docker inspect 容器ID 容器和宿主机之间共享数据 宿主机中添加文件 查看容器中是否也同步添加了文件 在宿主机目录下创建一个文件 查看容器中的挂载的目录下 我们在宿主机创建的问价也已经存在于容器中挂载的目录下 容器中挂载的文件修改 宿主机同步修改的数据 在宿主机中查看文件 发现文件修改也已经同步了 当容器停止运行之后 我们在宿主机对文件进行修改 那么容器中的文件会同步进行修改吗 停止运行容器 在宿主机中创建文件、修改文件 重新启动之前停止运行的容器（是重新启动而非新建容器） 在宿主机创建的文件已经同步了 查看修改的文件 修改的内容也已经同步 创建带权限的数据卷 ​ docker run -it -v 宿主机路径:容器内路径:ro 镜像名 ro : readonly 上述命令表示 Docker容器中的路径下文件 只读，不可以修改此路径下的文件内容，同时也不能创建文件（文件夹） DockerFile添加 是什么 可以简单理解为镜像的配置文件 使用DockFile创建镜像 在宿主机创建目录 用来存放生成的DockerFile 使用VOLUME指令编写DockerFile 使用这种方式 无法指定在宿主机中的目录，因为这个配置是可以通用的，如果指定某个具体的宿主机目录，那么使用此DockerFile生成的镜像，可能运行起来之后，在其他宿主机中没有对应的目录就会出错。但是Docker已经考虑了这个问题，在运行镜像生成容器的时候会随机生成目录。 使用DockerFile创建镜像 查看生成的镜像 并运行生成容器 查看容器内数据卷 查看宿主机内的对应所在的目录 docker inspect 容器ID 在 Docker容器中创建文件 在宿主机中查看 容器中 宿主机中 数据卷容器 定义 容器挂载数据卷之后，其他容器通过挂载这个容器中的数据卷实现容器之间的数据共享，那么被挂载的容器就被称为数据卷容器。 运行容器doc1，doc2和doc3挂载到doc1上 创建容器并命名为doc1 创建容器doc2，并挂载到doc1中 docker run -it --name doc2 --volumes-from doc1 chasingwind/centos 同理 创建doc3 并 挂载到doc1中 🤔：我们创建的doc2的时候，挂载的目录下存在doc1创建的文件，创建doc3的时候，挂载的目录下存在doc1和doc2创建的文件，那么在doc1中是否存在doc2和doc3创建的文件呢？ 存在。这就说明了Docker容器之间挂载之后，每个容器之间的数据是互通的 删除父容器doc1，查看doc2，doc3是否可以共享数据 容器doc2，doc3都创建的时候都挂载在容器doc1下，当我们删除容器doc1之后，容器doc2和doc3是否还能正常共享数据？ 查看容器doc3中是否有容器2创建的文件 总结：容器数据卷被删除之后，挂载的数据卷之间还是可以正常共享数据的。 总结 容器之间挂载之后，可以理解为每个容器的数据都来自同一个副本，只要容器还存在（比如容器被rm -f删除），那么数据都是可以继续进行共享的。数据卷的生命周期一直持续到没有容器使用它为止。 DockerFile解析是什么 DockFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 构建三步骤：编写DockerFile文件，docker build根据DockerFile生成镜像，docker run运行镜像生成容器 以CentOS的DockerFile为例 scratch 类似于Java中的Object，是所有镜像的父类 DockerFile构建过程解析 DockerFile内容基础知识 每条保留字指令都必须为大写字母并且后面都至少要跟随一个参数 指令执行顺序从上到下，顺序执行 **#**表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 Docker执行DockerFile的大致流程 Docker从基础镜像运行一个容器（FROM xxxx） 执行一条指令并对容器作出修改 将当前镜像提交生成一个新的镜像层 Docker再基于刚提交的镜像运行一个新的容器 执行DockerFile的下一条指令直到所有指令执行完成，生成最终的镜像文件 DockerFile关键字 FROM 基础镜像，表示当前镜像是基于哪个镜像的 MAINTAINER 镜像作者以及邮箱地址 RUN 容器构建时需要运行的命令 EXPOSE 当前容器对外暴露出的端口号 WORKDIR 指定在创建容器后，终端默认登录进入到的工作目录 ENV 用来在构建镜像的过程中设置环境变量 比如ENV MY_PATH /usr/local，相当于定义了一个变量，这个变量可以在后面的命令中直接使用，比如WORKDIR MY_PATH。 ADD 将宿主机目录下的文件复制进镜像，并且如果是压缩文件，会自动解压缩；如果是URL，也会自动处理 COPY 将从构建上下文中的源路径中的文件/目录复制到新的一层镜像内的目标路径的位置 举例：COPY src dest，或者COPY[“src”,dest”] VOLUME 容器数据卷 CMD 指定容器启动时要运行的命令 DockerFile中可以有多个CMD命令，但只有最后一个生效。 CMD会被docker run之后的参数替换 ENTRYPOINT 指定一个容器启动时要运行的命令 ENTRYPOINT和CMD，都是在指定容器启动程序以及参数 与RUN不同的是，ENTRYPOINT会追加命令而不是覆盖命令 ONBUILD 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，会触发父镜像的ONBUILD 案例 Base镜像（scratch） Docker Hub中的镜像99%都是在Base镜像的基础上之上安装和配置相关的软件实现的 CentOS自定义镜像 阿里云上的Docker镜像是精简版的，其中很多命令都不支持 例如vim和ifconfig两个命令都无法使用 编写DockerFile，生成我们自定义的CentOS 编写 使用自定义的DockerFile文件生成自定义的CentOS镜像 看到最后几条命令 就是在执行我们DockerFile中的命令 后面翻车了 启动不运行 原因是因为CMD和ENTRYPOINT的问题 修改Dockerfile2 重新创建 上面问题出现的原因 参考 简单来说就是： CMD给出的是一个容器的默认的可执行体。也就是容器启动以后，默认的执行的命令。重点就是这个“默认”。意味着，如果docker run没有指定任何的执行命令或者DockerFile里面也没有ENTRYPOINT，那么，就会使用cmd指定的默认的执行命令执行。同时也从侧面说明了ENTRYPOINT的含义，它才是真正的容器启动以后要执行命令。 所以这句话就给出了CMD命令的一个角色定位，它主要作用是默认的容器启动执行命令。（注意不是“全部”作用） 这也是为什么大多数网上博客论坛说的“CMD会被覆盖”，其实为什么会覆盖？因为CMD的角色定位就是默认，如果你不额外指定，那么就执行CMD的命令，否则呢？只要你指定了，那么就不会执行CMD，也就是CMD会被覆盖。 查看创建成功的镜像 运行我们的自定义镜像 可见运行之后 默认进入我们指定的目录 使用vim以及ifconfig 查看镜像的变更历史 ONBUILD命令案例 ONBUILD是在父镜像中定义使用，当有子镜像去继承这个父镜像的时候，子镜像build的时候就会触发父镜像中的ONBUILD命令 父镜像DockerFile 使用此DockerFile创建父镜像文件 子镜像文件DockerFile编写 继承自我们刚刚创建的父镜像 使用DockerFileson创建子镜像 可见在子镜像创建的过程中 执行了父镜像中的ONBUILD命令 Tomcat自定义镜像 在宿主机上创建好文件夹，放置我们需要的文件 这里有压缩文件也有非压缩文件，用于后面比较ADD和COPY的区别 创建DockerFile COPY命令的定义：从构建上下文中的源路径中的文件/目录复制到新的一层镜像内的目标路径的位置 构建上下文的源路径：其实就是DockerFile所在的路径 创建镜像 运行容器 测试 8888访问tomcat 查看宿主机的容器数据卷以及安装的Java Exec 不进入容器实现对容器的操作","categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/Docker/"}],"author":"ChasingWind"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"study","slug":"study","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/study/"},{"name":"Docker","slug":"Docker","permalink":"https://github.com/JustinLibo/JustinLibo.github.io.git/tags/Docker/"}]}